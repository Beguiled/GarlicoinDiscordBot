//
// Garlicoin Discord Bot
// A bot written for NodeJS to compliment a Garlicoin cryptocurrency Discord server
// https://github.com/Beguiled/GarlicoinDiscordBot
//
// Created by Jason Egan (beguil3d#2285)
// Version 1.0

// Changelog
// 2018/04/23   Version 1.0 - Initial Release

let BOT_VERSION = "2.1.0";

// Define Discord objects
let Discord = require("discord.js");
let discordClient = new Discord.Client();

// Define helper objects
let http = require('http');
let https = require('https');
let fs = require('fs');
const { channel } = require("diagnostics_channel");

// Define start up timestamp (mainly for logging)
// We can then store all logging output to a timestamped log file which is helpful in case the script must be restarted
let startup = new Date();
let logFile = './logs/' + startup.toISOString().replace(/T|Z|-|:/gi, '').substr(0, 14) + '.log';

// JSON data storage objects
let config = []
let members = []

//Read config and memberts
try {
    config = require("./config.json");
} catch (e) {
    consoleLog(`Error reading config.json\n${e}`)    
}

try {
    members = require("./members.json");
} catch (e) {
    consoleLog(`Error reading members.json\n${e}`)    
}

// Data object declarations
let jsonStats = {};
let jsonBlocks = {};
let jsonWorkers = {};
let jsonMiners = {};
let jsonPayments = {};
let latestPoolVelocity = [0, 0, 0, 0, 0, 0];
let latestPoolBlockData = [0, 0, 0];
let latestBlockHeight = 0;
let latestConfirmed = 0;
let botAdminRoles = [];
let botChannels = [];
let serverChannels = [];
let latestBlock = [];
let lastMessage = '';


// Announce start up
consoleLog(`Garlicoin Discord Bot version ${BOT_VERSION} starting up...`);
consoleLog('Visit https://github.com/garlico-in/GarlicoinDiscordBot for help and updates');

// Discord Client "ready" event
discordClient.on("ready", () => {
    // Set the username to the configured name in config.json
    consoleLog(`Setting bot name to ${config.name}`);
    discordClient.user.setUsername(config.name);

    // Populate the botAdminRoles array
    consoleLog(`Setting admin roles to ${config.bot_admin_roles}`);
    botAdminRoles = config.bot_admin_roles.split(",");

    //Define channels
    consoleLog(`Setting channels to ${config.channels}`);
    botChannels = config.channels.split(",");

    // Poll the pool's API for the stats JSON data, then update the poolBlockData array
    consoleLog(`Getting initial pool API data`);
    try{
        getJsonPayments().then(
            getJsonMiners().then(
            result => getJsonWorkers().then(
            result => getJsonBlocks().then(
            result => getJsonStats().then(
            result => getPoolBlockData(                    
        ))))));
    }catch(e){
        consoleLog(`Exception in gathering pool API data \n${e}`)
    }
    // Set the default activity to 'watching Garlicoin' 
    discordClient.user.setActivity(`Garlicoin | ${config.prefix}help`, {
        type: 'WATCHING'
    }).catch(O_o => {});

    serverChannels = discordClient.channels

    consoleLog(`Listening for commands with prefix ${config.prefix}`);

    // Announce start up is complete
    consoleLog(`${config.name} online`);
});

// Discord Client "guildMemberAdd" event
// Welcome the new member to your server!
discordClient.on("guildMemberAdd", member => {
    let guild = member.guild;
    guild.defaultChannel.send(`Welcome ${member.user} to the ${config.server_name} server! Use \`${config.prefix}help\` to see what commands are available for you to use.`).catch(function (error) {
        consoleLog(`Error encountered in guildMemberAdd event:\r\n${error}`)
    });
});

// Discord Client "message" event
// This parses any incoming messages to determine if the bot needs to respond
discordClient.on("message", message => {
    // Ignore the message if it has been generated by a bot
    if (message.author.bot) return;

    // Ignore the message if the prefix does not exist
    if (message.content.indexOf(config.prefix) !== 0) return;

    // Store the message author for ease of reference later
    let messageSender = message.member.user;

    // Define the member in the members JSON object if they haven't been seen yet
    // This will avoid issues when querying data points that are not yet defined
    if (!members[messageSender.id])
        members[messageSender.id] = {};

    // Split the message into an array of arguments and set the first element as the command
    let args = message.content.slice(config.prefix.length).trim().split(/ +/g);
    let command = args.shift().toLowerCase();

    // Determine if the user is in a role defined in the "bot_admin_roles" declaration to allow for admin commands
    let isAdmin = false;
    for (var i = 0; i < botAdminRoles.length; i++) {
        if (message.member.roles === botAdminRoles[i])
            isAdmin = true;
    }

    // Bot Admin Commands
    if (isAdmin) {
        if (command === "echo") {
            // Delete the command message
            message.delete().catch(O_o => {});
            // Echo the message
            let msg = args.join(" ");
            sendReply(message, msg);
        } else if (command === "broadcast") {
            // Delete the command message
            message.delete().catch(O_o => {});
            // Broadcast the message
            let msg = args.join(" ");
            broadcast(msg);
        } else if (command === "save") {
            // Execute saveAll
            saveAll();
            // Notify the message author of the completion of the task
            let messageAuthor = message.author;
            messageAuthor.send("All configurations have been saved.");
            // Delete the command message
            message.delete().catch(O_o => {});
        }
    }

    // General Commands
    if (command === "help") {
        // Display the list of available commands
        // -- Example of how commands should display --
        // Member Commands
        //```\n
        //me        : View your details\n
        //register  : Set your wallet address\n
        //notify    : Receive block notifications\n
        //```
        // Pool Commands
        //```\n
        //block     : Pool block data\n
        //poolstats : Pool statistics\n
        //velocity  : Pool solve velocity\n
        //workers   : List of current pool workers\n
        //Payments  : Payment info
        //```
        // Market Data
        //```
        //cap       : Garlicoin market cap\n
        //market    : Current crypto market data\n
        //```

        let msg = `${messageSender}, here are my available commands:\n`;

        let embed = {
            "color": 11510597,
            "fields": [
                {
                    "name": "Member Commands",
                    "value": "```\nme        : View your details\nregister  : Set or clear your wallet address\nnotify    : Receive block notifications\n```"
			  },
                {
                    "name": "Pool Commands",
                    "value": "```\nblock     : Pool block data\npoolstats : Pool statistics\nvelocity  : Pool solve velocity\nworkers   : List of current pool workers\n```"
			  },
                {
                    "name": "Market Data",
                    "value": "```\ncap       : Garlicoin market cap\nmarket    : Current crypto market data\n```"
			  }
			]
        };
        message.channel.send(msg, {
            embed
        });
    } else if (command === "block" || command === "blocks") {
        // Display current pool block data
        let msg = '';
        msg += '```ml\n';
        msg += `Confirmed : ${latestPoolBlockData[0]+489}\n`;
        msg += `Pending   : ${latestPoolBlockData[1]}\n`;
        msg += `Kicked    : ${latestPoolBlockData[2]}\n`;
        msg += '```';
        sendReply(message, msg);
    } else if (command === "cap") {
        // Display market cap data for Garlicoin via CoinMarketCap

        getCoinData("garlicoin").then(result => {
            let priceUSD = result.garlicoin.usd;
            let vol24h = result.garlicoin.usd_24h_vol;
            let chg24h = result.garlicoin.usd_24h_change;
            let mktCap = result.garlicoin.usd_market_cap;
            let supply = result.garlicoin.usd_market_cap/result.garlicoin.usd;
            let msg = '';
            msg += '```md\n';
            msg += ' Market Cap Data\n';
            msg += '------------------------\n';
            msg += `Price   : ${priceUSD} USD\n`;
            msg += `24h Vol : ${vol24h} USD\n`;
            msg += `24h Chg : ${Number(chg24h) > 0 ? '+' : ''}${chg24h}%\n`;
            msg += `Mkt Cap : ${Number(mktCap).toFixed(2)} USD\n`;
            msg += `Supply  : ${supply} GRLC\n`;
            msg += '```';
            sendReply(message, msg);
        });
    } else if (command === "market") {
        // Display market data pulled from CoinMarketCap
        let coins = ["garlicoin", "bitcoin", "ethereum", "bitflowers", "chia", "litecoin", "nano", "banano", "dogecoin", "binancecoin", "avalanche-2"];
        let combinedResult = [];
        Promise.all(coins.map(coin => getCoinData(coin)))
            .then((combinedResult) => {
                let msg = '';
                msg += '\`\`\`asciidoc\n';
                msg += ' Current Cryptocurrency Market Data (via CoinMarketCap)\n';
                msg += '----------------------------------------------------------------\n';
                msg += ' Coin         Value (USD)      1hr    |  24hr    |   7d     |   Mkt Cap\n';
                for (let i = 0; i < coins.length; i++) {
                    let coinData = combinedResult[i][coins[i]];
                    let price = Number.parseFloat(coinData.usd).toFixed(coinData.usd < 10 ? 4 : 2).padStart(8, " ");
                    let change1h = Number.parseFloat(coinData.usd_24h_change).toFixed(2);
                    let change24h = Number.parseFloat(coinData.usd_24h_change).toFixed(2);
                    let change7d = Number.parseFloat(coinData.usd_24h_change).toFixed(2);
                    let mktcap = Number.parseFloat(coinData.usd_market_cap);
                    let denom = "";
                    if (mktcap > 1000000000) {
                        denom = "B";
                        mktcap = mktcap / 1000000000;
                    }
                    if (mktcap > 1000000) {
                        denom = "M";
                        mktcap = mktcap / 1000000;
                    }
                    if (mktcap > 1000) {
                        denom = "K";
                        mktcap = mktcap / 1000;
                    }
                    mktcap = mktcap.toFixed(2); //.padStart(6, " ");
                    if (Number(change1h) > 0) change1h = "+" + change1h;
                    if (Number(change24h) > 0) change24h = "+" + change24h;
                    if (Number(change7d) > 0) change7d = "+" + change7d;
                    change1h = change1h.padStart(7, " ");
                    change24h = change24h.padStart(7, " ");
                    change7d = change7d.padStart(7, " ");
                    mktcap = mktcap.padStart(8, " ");
                    msg += ` ${coins[i].padEnd(11, " ")}`;
                    msg += `  $ ${price}`;
                    msg += `     `;
                    msg += `${change1h}%`;
                    msg += ` | `;
                    msg += `${change24h}%`;
                    msg += ` | `;
                    msg += `${change7d}%`;
                    msg += ` | `;
                    msg += `${mktcap}${denom}`;
                    msg += `\n`;
                }
                msg += '\`\`\`';
                sendReply(message, msg);
            });

    } else if (command === "me") {
        // Display the user's current pool details (if they've used register to define their wallet address)

        // If the definition does not exist, create it as an empty value
        if (!members[messageSender.id].wallet)
            members[messageSender.id].wallet = "";

        let msg = '';
        let tempHashrate = 0;
        if (members[messageSender.id].wallet > "") {
            let walletID = members[messageSender.id].wallet;
            let minerNode = jsonMiners.body.primary.shared;
            let payout = 0;
            let shares = 0;
            let invalid = 0;
            let stale = 0

            //let hashratePromise = new Promise(function(resolve, reject) {
                try{
                    for (i = 0; i < jsonMiners.body.primary.shared.length; i++) {
                        let miner = jsonMiners.body.primary.shared[i].miner;
                        if(miner == walletID){
                            payout = jsonPayments.body.primary.generate[miner];
                            //resolve(tempHashrate = minerNode[i].hashrate);
                            tempHashrate = minerNode[i].hashrate;
                            shares = minerNode[i].shares.valid;
                            invalid = minerNode[i].shares.invalid;
                            stale = minerNode[i].shares.stale;
                        }
                    }
                }catch (e){
                    consoleLog(e);
                    //reject(e);
                }
            //});

            try{
            //hashratePromise//.then(result => function() {
            msg = '';
            msg += '```';
            msg += `             Address : ${walletID}\n`;
            msg += `            Hashrate : ${tempHashrate}\n`
            msg += `    Estimated Payout : ${payout}\n`;
            msg += ` Shares (This Round) : ${shares}\n`;
            msg += `Invalid (This Round) : ${invalid}\n`;
            msg += `  Stale (This Round) : ${stale}\n`;
            msg += '```';
            //});
            }catch (e){
                consoleLog(e);
            }
        } else {
            // User has not set their wallet address yet - instruct them on how to do so
            msg = `${messageSender} you have not defined your wallet address yet. Please use \`${config.prefix}register [wallet]\` to do so.`;
        }
        sendReply(message, msg);
    } else if (command === "notify") {
        // Allow members to set a notification preference for when blocks are solved and confirmed
        // If member is not yet defined in members.json, create it

        // If the definition does not exist, create it as an empty value (aka "off")
        if (!members[messageSender.id].block_notify)
            members[messageSender.id].block_notify = "";

        let msg = '';
        if (args[0] === "on") {
            members[messageSender.id].block_notify = "on";
            msg += `${messageSender}, you will be notified when blocks are solved or confirmed.`;
            saveMembers("Member notification setting updated");
        } else if (args[0] === "off") {
            members[messageSender.id].block_notify = "";
            msg += `${messageSender}, you will not be notified when blocks are solved or confirmed.`;
            saveMembers("Member notification setting updated");
        } else {
            let setting = members[messageSender.id].block_notify == "on" ? "`on`" : "`off`";
            msg += `${messageSender} your notification setting is currently ${setting}. You can change it by using \`${config.prefix}notify [on|off]\``;
        }
        sendReply(message, msg);
    } else if (command === "poolstats") {
        // Display a general list of pool statistics
        let msg = '';
        msg += '```ml\n';
        msg += 'Info\n'
        msg += `  Name               : The Garlicoin Federation Pool\n`;
        msg += `  Website            : https://blinkhash.com/mining/c19a9909-8be9-4cf9-bef4-408ca8165594/dashboard\n`;
        msg += `  Domain             : garlico.in\n`;
        msg += `  Coin               : ${jsonStats.body.primary.config.coin}\n`;    
        msg += `  Symbol             : ${jsonStats.body.primary.config.symbol}\n`;  
        msg += `  Algorithm          : ${jsonStats.body.primary.config.algorithm}\n`; 
        msg += `  Payment Interval   : ${jsonStats.body.primary.config.paymentInterval}s\n`;
        msg += `  Minimum Payout     : ${jsonStats.body.primary.config.minPayment} GRLC\n`;
        msg += `  Recipient Fee      : ${jsonStats.body.primary.config.recipientFee}%\n`;
        msg += 'Blocks\n'
        msg += `  Confirmed          : ${latestPoolBlockData[0]+489}\n`;
        msg += `  Pending            : ${latestPoolBlockData[1]}\n`;
        msg += `  Kicked             : ${latestPoolBlockData[2]}\n`;
        msg += 'Workers\n';
        msg += `  Count              : ${jsonMiners.body.primary.shared.length}\n`;
        msg += `  Pooled Hashrate    : ${getHashInt( jsonStats.body.primary.hashrate.shared)}\n`;
        msg += `  Solo Hashrate      : ${getHashInt( jsonStats.body.primary.hashrate.solo)}\n`;
        msg += 'Shares\n';
        msg += `  Valid              : ${jsonStats.body.primary.shares.valid}\n`;
        msg += `  Stale              : ${jsonStats.body.primary.shares.stale}\n`;
        msg += `  Invalid            : ${jsonStats.body.primary.shares.invalid}\n`;
        msg += 'Payments\n';
        msg += `  Total Paid         : ${precisionRound(jsonStats.body.primary.payments.total, 6)} GRLC\n`;
        msg += `  Next Payout        : ${new Date(jsonStats.body.primary.payments.next).toISOString()}\n`;
        msg += `  Last Payout        : ${new Date(jsonStats.body.primary.payments.last).toISOString()}\n`;
        msg += 'Servers\n';
        msg += `  Fastest (Beta)     : stratum+tcp://accelerator.pool.garlico.in:3002\n`;
        msg += `  Best Available     : stratum+tcp://pool.garlico.in:3002\n`;
        msg += `  API                : http://pool.garlico.in:3001\n`;
        msg += 'Regional Servers\n';
        msg += `  Montreal           : stratum+tcp://ca.node.garlico.in:3002\n`;
        msg += `  North California   : stratum+tcp://us.node.garlico.in:3002\n`;
        msg += `  Frankfurt          : stratum+tcp://de.node.garlico.in:3002\n`;
        msg += `  Singapore          : stratum+tcp://sg.node.garlico.in:3002\n`;
        msg += 'Ports\n';
        msg += `  3002               : TCP Pooled Vardiff (I:4, Mi:1, Mx:25) \n`;
        msg += `  3003               : TLS Pooled Vardiff (I:4, Mi:1, Mx:25)\n`;
        msg += `  3069               : TCP Solo Vardiff (I:25, Mi:1, Mx:512)\n`;
        msg += '```';
        sendReply(message, msg);
    } else if (command === "register") {
        // Allow the member to set their wallet address
        // If member is not yet defined in members.json, create it
        if (!members[messageSender.id])
            members[messageSender.id] = {};

        let msg = '';
        if (args.length == 0) {
            msg += `${messageSender}, the correct format for this command is:\n`;
            msg += '```\n';
            msg += `${config.prefix}register [wallet]  : Set your wallet address\n`;
            msg += `${config.prefix}register forget    : Remove your wallet address\n`;
            msg += '```\n';
        } else if (args[0] == "forget") {
            members[messageSender.id].wallet = "";
            msg = `${messageSender}, your stored wallet data has been cleared.`;
            saveMembers("Member wallet data updated");
        } else {
            msg = `${messageSender}, your wallet has been set to: \`${args[0]}\``;
            members[messageSender.id].wallet = args[0];
            saveMembers("Member wallet data updated");
        }
        sendReply(message, msg);
    } else if (command === "velocity") {
        // Display the current pool block solve velocity (usually only good for up to about 12 hours of data from the API)
        getVelocity().then(function (result) {

            let count1 = result[0].toFixed(2).padStart(6, " ").padEnd(7, " ");
            let count6 = result[1].toFixed(2).padStart(6, " ").padEnd(7, " ");
            let count12 = result[2].toFixed(2).padStart(6, " ").padEnd(7, " ");
            let count24 = result[3].toFixed(2).padStart(6, " ").padEnd(7, " ");
            let count48 = result[4].toFixed(2).padStart(6, " ").padEnd(7, " ");
            let count168 = result[5].toFixed(2).padStart(6, " ").padEnd(7, " ");
            let count1v = Number(count1).toFixed(2).padStart(6, " ").padEnd(8, " ");
            let count6v = (Number(count6) / 6).toFixed(2).padStart(6, " ").padEnd(8, " ");
            let count12v = (Number(count12) / 12).toFixed(2).padStart(6, " ").padEnd(8, " ");
            let count24v = (Number(count24) / 24).toFixed(2).padStart(6, " ").padEnd(8, " ");
            let count48v = (Number(count48) / 48).toFixed(2).padStart(6, " ").padEnd(8, " ");
            let count168v = (Number(count168) / 168).toFixed(2).padStart(6, " ").padEnd(8, " ");

            // Build the message output
            // Always show the periods of last 1 and 6 hours
            // Only show 12+ hours if data exists
            let msg = '';
            msg += '```prolog\n';
            msg += `+-------------------------+\n`;
            msg += `| Period | Count | Hourly |\n`;
            msg += `+-------------------------+\n`;
            msg += `|   1hr  |${count1}|${count1v}|\n`;
            msg += `|   6hr  |${count6}|${count6v}|\n`;
            if (count12v > 0) msg += `|  12hr  |${count12}|${count12v}|\n`;
            if (count24v > 0) msg += `|  24hr  |${count24}|${count24v}|\n`;
            if (count48v > 0) msg += `|  48hr  |${count48}|${count48v}|\n`;
            if (count168v > 0) msg += `|  7day  |${count168}|${count168v}|\n`;
            msg += `+-------------------------+\n`;
            msg += '```';

            sendReply(message, msg);
        }, function (err) {
            consoleLog(err);
        });
    } else if (command === "workers") {
        // Display the list of workers currently mining and their hashrate
        let msg = '';
        let workers = jsonMiners.body.primary.shared;
        let workerArray = [];
        let idx = 0;
        Object.keys(workers).forEach(worker_iterator => {
            let w = {
                worker: workers[worker_iterator].miner,
                hashInt: getHashInt(workers[worker_iterator].hashrate),
                hashrate: workers[worker_iterator].hashrate
            };
            workerArray[idx] = w;
            idx++;
        });

        // Sort from highest to lowest hashrate
        workerArray.sort(function (a, b) {
            return a.hashrate- b.hashrate
        }).reverse();

        // Display list
        let padStart = 1;
        if (workerArray.length >= 10) padStart++;
        if (workerArray.length >= 100) padStart++;
        msg += '```css\n';
        msg += `${jsonMiners.body.primary.shared.length.toString().padStart(4 + padStart)} Miners -- ${getHashInt(jsonStats.body.primary.hashrate.shared)}\n`;
        for (let i = 0; i < workerArray.length; i++) {
            let wallet = workerArray[i].worker;
            msg += ` ${(i + 1).toString().padStart(padStart)}  ${wallet.substr(0,6)}...${wallet.substr(-4)}  ${workerArray[i].hashInt.toString().padStart(9)}\n`;
        }
        msg += '```';
        sendReply(message, msg);
    } else {
        // Do nothing
    }
}); // END MESSAGE HANDLER


// Helpers
//////////

// Write out to the console (and log file)
function consoleLog(text) {
    let str = `[${timeStamp()}] ${text}`;
    console.log(str);
    fs.appendFile(logFile, `${str}\r\n`, function (err) {
        // if (err) throw err;
    });
}

// A simple rounding function
function precisionRound(number, precision) {
    let factor = Math.pow(10, precision);
    return Math.round(number * factor) / factor;
}

// Return the current timestamp in YYYYMMDD HHMMSS format
function timeStamp() {
    let now = new Date();
    let date = [now.getFullYear(), now.getMonth() + 1, now.getDate()];
    let time = [now.getHours(), now.getMinutes(), now.getSeconds()];

    // If less than 10, add a zero
    if (date[1] < 10)
        date[1] = "0" + date[1];
    for (let i = 0; i < 3; i++) {
        if (time[i] < 10) {
            time[i] = "0" + time[i];
        }
    }

    return date.join("") + " " + time.join(":");
}

// Write data to the selected file
function writeToFile(file, data) {
    let fs = require('fs');
    fs.writeFile(file, data, 'utf8', function (err) {
        if (err)
            consoleLog(`Error attempting to write out ${file}\n${err}`);
    });
}

// Reply to an incoming message with given text
function sendReply(message, text) {
    message.channel.send(text).catch(function (error) {
        consoleLog(`Error encountered in sendReply\r\n${error}`)
    });
}

// A simple "Under Development" style message to prepend any new functionality
// Note: this may never be used
function underDevelopment(message) {
    sendReply(message, "\`This functionality is under development.\`");
}

// Query the CoinMarketCap API for the provided coin's value
function getCoinData(coin) {
    return new Promise(function (resolve, reject) {
        let url = `https://api.coingecko.com/api/v3/simple/price?ids=${coin}&vs_currencies=usd&include_market_cap=true&include_24hr_vol=true&include_24hr_change=true&include_last_updated_at=true`;
        https.get(url, (res) => {
            let data = '';

            res.on('data', (chunk) => {
                data += chunk;
            });

            res.on('end', () => {
                resolve(JSON.parse(data));
            }).on('error', (e) => {
                consoleLog(`Error in getCoinData\n${e}`);
                reject(e);
            });
        });
    });
}

// Query the pool's API for stats data
function getJsonStats() {
    return new Promise(function (resolve, reject) {
        let url = `${config.pool_api_url}/statistics`;
        http.get(url, (res) => {
            let data = '';

            res.on('data', (chunk) => {
                data += chunk;
            });

            res.on('end', () => {
                try {
                    let json = JSON.parse(data);
                    jsonStats = json;
                    consoleLog(`Successful: getJsonStats collection`);
                    resolve(jsonStats);
                } catch (e) {
                    consoleLog(`Error in getJsonStats: ${e}`);
                    resolve(jsonStats);
                }
            }).on('error', (e) => {
                consoleLog(`Error in getJsonStats: ${e}`);
                resolve(jsonStats);
            });
        });
    });
}

//get block data from API
function getJsonBlocks() {
    return new Promise(function (resolve, reject) {
        let url = `${config.pool_api_url}/blocks`;
        http.get(url, (res) => {
            let data = '';

            res.on('data', (chunk) => {
                data += chunk;
            });

            res.on('end', () => {
                try {
                    let json = JSON.parse(data);
                    jsonBlocks = json;
                    consoleLog(`Successful: getJsonBlocks collection`);
                    resolve(jsonBlocks);
                } catch (e) {
                    consoleLog(`Error in getJsonBlocks: ${e}`);
                    resolve(jsonBlocks);
                }
            }).on('error', (e) => {
                consoleLog(`Error in getJsonBlocks: ${e}`);
                resolve(jsonBlocks);
            });
        });
    });
}

//get worker data from api
function getJsonWorkers() {
    return new Promise(function (resolve, reject) {
        let url = `${config.pool_api_url}/workers`;
        http.get(url, (res) => {
            let data = '';

            res.on('data', (chunk) => {
                data += chunk;
            });

            res.on('end', () => {
                try {
                    let json = JSON.parse(data);
                    jsonWorkers = json;
                    consoleLog(`Successful: getJsonWorkers collection`);
                    resolve(jsonWorkers);
                } catch (e) {
                    consoleLog(`Error in getJsonWorkers: ${e}`);
                    resolve(jsonWorkers);
                }
            }).on('error', (e) => {
                consoleLog(`Error in getJsonWorkers: ${e}`);
                resolve(jsonWorkers);
            });
        });
    });
}

//get miner data from api
function getJsonMiners() {
    return new Promise(function (resolve, reject) {
        let url = `${config.pool_api_url}/miners`;
        http.get(url, (res) => {
            let data = '';

            res.on('data', (chunk) => {
                data += chunk;
            });

            res.on('end', () => {
                try {
                    let json = JSON.parse(data);
                    jsonMiners = json;
                    consoleLog(`Successful: getJsonMiners collection`);
                    resolve(jsonMiners);
                } catch (e) {
                    consoleLog(`Error in getJsonMiners: ${e}`);
                    resolve(jsonMiners);
                }
            }).on('error', (e) => {
                consoleLog(`Error in getJsonMiners: ${e}`);
                resolve(jsonMiners);
            });
        });
    });
}

//get payment data from api
function getJsonPayments() {
    return new Promise(function (resolve, reject) {
        let url = `${config.pool_api_url}/payments`;
        http.get(url, (res) => {
            let data = '';

            res.on('data', (chunk) => {
                data += chunk;
            });

            res.on('end', () => {
                try {
                    let json = JSON.parse(data);
                    jsonPayments = json;
                    consoleLog(`Successful: getJsonPayments collection`);
                    resolve(jsonPayments);
                } catch (e) {
                    consoleLog(`Error in getJsonPayments: ${e}`);
                    resolve(jsonPayments);
                }
            }).on('error', (e) => {
                consoleLog(`Error in getJsonPaymentss: ${e}`);
                resolve(jsonPayments);
            });
        });
    });
}

// Calculate the current block solve velocity for the pool
function getVelocity() {
    
    
    // NOMP codebase
    if (config.pool_codebase.toLowerCase() === 'nomp') {
        return new Promise(function (resolve, reject) {
            let url = `${config.pool_api_url}/historical`;
            http.get(url, (res) => {
                let data = '';

                res.on('data', (chunk) => {
                    data += chunk;
                });

                res.on('end', () => {
                    try {
                        let json = JSON.parse(data);
                        let result = [0, 0, 0, 0, 0, 0];
                        let dateStampNow = new Date();
                        let blockHeight = 0;
                        let oldest_data_point = 0;
                        for (let i = 0; i < json.length; i++) {
                            let dateStamp = new Date(json[i].body.primary[0].time * 1000);
                            let ticksPerHour = 3600000;
                            let timeDiff = (dateStampNow - dateStamp) / ticksPerHour;

                            if (oldest_data_point == 0)
                                oldest_data_point = Math.ceil(timeDiff); // Determine how many hours ago the oldest data point is

                            let pendingBlocks = latestPoolBlockData[1];
                            let confirmedBlocks = latestPoolBlockData[0]+489;
                            curBlockHeight = Number(pendingBlocks) + Number(confirmedBlocks);
                            if (curBlockHeight > blockHeight) {
                                pendBlock = pendingBlocks;
                                confBlock = confirmedBlocks;
                                blockHeight = curBlockHeight;
                                if (timeDiff <= 1) result[0] = Number(result[0]) + 1; // 1hr
                                if (timeDiff <= 6) result[1] = Number(result[1]) + 1; // 6hr
                                if (timeDiff <= 12) result[2] = Number(result[2]) + 1; // 12hr
                                if (timeDiff <= 24) result[3] = Number(result[3]) + 1; // 24hr
                                if (timeDiff <= 48) result[4] = Number(result[4]) + 1; // 48hr
                                if (timeDiff <= 168) result[5] = Number(result[5]) + 1; // 7day
                            }
                        }

                        // Zero out any data points "older" than oldest_data_point to avoid them being displayed
                        if (oldest_data_point < 168)
                            result[5] = 0;
                        if (oldest_data_point < 48)
                            result[4] = 0;
                        if (oldest_data_point < 24)
                            result[3] = 0;
                        if (oldest_data_point < 12)
                            result[2] = 0;
                        if (oldest_data_point < 6)
                            result[1] = 0;

                        latestPoolVelocity = result;
                        resolve(result);
                    } catch (e) {
                        consoleLog(`Exception in getVelocity\r\n${e}`);
                        resolve(latestPoolVelocity);
                    }
                }).on('error', (e) => {
                    consoleLog(`Error in getVelocity\r\n${e}`);
                    resolve(latestPoolVelocity);
                });
            });
        });
    }
    
    return [0, 0, 0, 0, 0, 0];
}

// Set the current Hash Rate and Miner Count as the bot's activity
function setHashRateActivity() {
    let activity = `${jsonStats.body.primary.hashrate.shared} | ${jsonStats.body.primary.status.workers} mining | ${config.prefix}help`;
    discordClient.user.setActivity(activity, {
        type: 'WATCHING'
    }).catch(O_o => {});
}

// Check for any changes in the pool block data and broadcast notifications if something has changed
function getPoolBlockData() {
    let blockNode = jsonBlocks.body.primary;
    let msg = '';

    //Check for undefined objects
    if (typeof latestBlock === 'undefined'){
        latestBlock = blockNode.pending[0];
    }
    if (typeof latestConfirmedBlock === 'undefined'){
        latestConfirmedBlock = blockNode.confirmed[0];
    }
    
    try{
        if (blockNode.pending[0].height > latestBlock.height) {
            latestBlock = blockNode.pending[0];
            consoleLog(`New block solved: #${jsonStats.body.primary.blocks.valid+489 + blockNode.pending.length} (${jsonStats.body.primary.blocks.valid+489} confirmed, ${blockNode.pending.length} pending)`);
            msg += '```css\n';
            msg += `We solved a block! (#${blockNode.pending[0].height})\n`;
            //msg += `${jsonStats.body.primary.blocks.valid+489} confirmed, ${blockNode.pending.length} pending\n`;
            //msg += ` Difficulty: ${latestBlock.difficulty}\n`;
            //msg += `       Hash: ${latestBlock.hash}\n`;
            //msg += `       Luck: ${latestBlock.luck}\n`;
            //msg += `     Reward: ${latestBlock.reward/100000000}\n`;
            //msg += `      Round: ${latestBlock.round}\n`;
            msg += `       Solo: ${latestBlock.solo}\n`;
            //msg += `Transaction: ${latestBlock.transaction}\n`;
            msg += `     Worker: ${latestBlock.worker}\n`;
            msg += '```';
        }
    }catch(e) {
        consoleLog(e)
    }
    if (blockNode.confirmed[0].height > latestConfirmedBlock.height) {
        consoleLog(`Block confirmed: #${blockNode.confirmed.length} (${blockNode.confirmed.length} confirmed, ${blockNode.pending.length} pending)`);
        msg += '```css\n';
        msg += `Block #${blockNode.confirmed[0].height} has been confirmed!\n`;
        msg += `${latestPoolBlockData[0]+489} confirmed, ${blockNode.pending.length} pending\n`;
        msg += '```';
    }
    if (msg.length > 0) {

        // Add any notifications for members seeking mentions
        Object.keys(members).forEach(member => {
            if (members[member].block_notify === "on" && latestBlock.worker === members[member].wallet)
                msg += `<@${member}> `;
        });
        broadcastBlock(msg);
    }

    latestPoolBlockData = [jsonStats.body.primary.blocks.valid, blockNode.pending.length, blockNode.kicked.length];
    latestBlockHeight = blockNode.confirmed.length + blockNode.pending.length;
    latestConfirmed = blockNode.confirmed.length;
    latestBlock = blockNode.pending[0];
    latestConfirmedBlock = blockNode.confirmed[0];
}

// Broadcasts message to all channels in the channels 
function broadcast(message) {
    if (message.length == 0) return;

//    for(channel in discordClient.channels)(function (chan) {
//        if (chan.type === "text") {
//            chan.send(message).catch(O_o => {}); // Catch to avoid logging channel permission issues
//        }
//    });
}

function broadcastBlock(message) {
    if (message.length == 0) return;

    try {
        botChannels.forEach(async function (id){
            if(lastMessage != message){
                const channel = await discordClient.channels.fetch(id);
                channel.send(message);
            }else{
                consoleLog(`Duplicate Block Message Suppressed`)
            }
        });
        lastMessage = message;
    } catch (e) {
        consoleLog(`Error broadcating blocks to channels: ${e}`)
    }
}

// Determine the amount being paid out
// Note: This is nowhere near an exact value. It bases the result on the current pool hash rate which can fluctuate
// greatly based on the number of workers are involved. Ultimately this result is much closer in larger pools.
// The API does not surface the current submitted share data so we have to do a best guess based on hash rate reports.
function calculatePayout(hashrate) {
    return precisionRound(hashrate / parseFloat(jsonStats.body.primary.hashrate.shared) * 50, 5) + " GRLC";
}

// Convert a hashrateString into an int representing hashes per second
function getHashInt(hashrate) {
    let workerHashrate = hashrate;
    let hashSize = hashrate;
    if (hashSize < 1000) workerHashrate = (workerHashrate).toString()+` H/s`
    else if (hashSize < 1000000 && hashSize >= 1000) workerHashrate = (workerHashrate/1000).toString()+` KH/s`;
    else if (hashSize >= 1000000)  workerHashrate = (workerHashrate/1000000).toString()+` MH/s`;
    return workerHashrate;
}

// Saves
//////////

function saveAll() {
    saveConfig();
    saveMembers();
}

function saveConfig() {
    consoleLog('Writing config to config.json');
    writeToFile('./config.json', JSON.stringify(config));
}

function saveMembers(reason) {
    consoleLog('Writing members to members.json');
    if (reason > "") consoleLog(`Reason: ${reason}`);
    writeToFile('./members.json', JSON.stringify(members));
}

// Activate any timer-based functions
setInterval(getJsonPayments, 10000);
setInterval(getJsonMiners, 10000);
setInterval(getJsonWorkers, 10000);
setInterval(getJsonBlocks, 10000);
setInterval(getJsonStats, 10000);
setInterval(getPoolBlockData, 10000);
setInterval(setHashRateActivity, 10000);

// Log in to Discord to be present online
try{
    discordClient.login(config.token);
}
catch(e){
    consoleLog(`Error in discord login\n${e}`)
}
